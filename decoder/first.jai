#import "Basic";
#import "File";

Opcode :: enum
{
    MOV_REG2RM :: 0b100010;
}

Mod :: enum
{
    Mem   :: 0b00;
    Mem8  :: 0b01;
    Mem16 :: 0b10;
    Reg   :: 0b11;
}

// Or'ed with 'w' as the high (4th) bit
EncodedReg :: enum
{
    al;
    cl;
    dl;
    bl;
    ah;
    ch;
    dh;
    bh;
    ax;
    cx;
    dx;
    bx;
    sp;
    bp;
    si;
    di;
}

RegToRegName :: ( rmBits: int, wBit: int ) -> string
{
    index := (wBit << 3) | (rmBits & 0x7);
    return type_info(EncodedReg).names[ index ];
}

TakeByte :: ( in: **u8, input: string ) -> u8, bool
{
    if <<in + 1 > input.data + input.count
        return 0, false;

    result := <<(<<in);       // Awesome syntax ftw
    <<in += 1;
    return result, true;
}

main :: ()
{
    args := get_command_line_arguments();
    if args.count < 2
    {
        print( "ERROR: Need a file to decode!" );
        exit( 1 );
    }

    filename := args[1];
    input, inputOk := read_entire_file( filename );

    if !inputOk
    {
        print( "ERROR: Couldn't read file '%'", filename );
        exit( 1 );
    }

    in: *u8 = input.data;
    out: String_Builder;
    
    append( *out, tprint( "; Decoded from % (autogenerated)\n\n", filename ) );
    append( *out, "bits 16\n\n" );

    while true
    {
        b, ok := TakeByte( *in, input );
        if !ok
            break;

        opcode := cast(Opcode) (b >> 2) & 0x3F;
        d := (b >> 1) & 0x1;
        w := b & 0x1;

        if opcode ==
        {
            case .MOV_REG2RM;
            {
                append( *out, "mov " );

                b, ok = TakeByte( *in, input );
                mod := cast(Mod) (b >> 6) & 0x3;
                reg := (b >> 3) & 0x7;
                rm := b & 0x7;

                if mod ==
                {
                    case;
                    assert( false, "Implement me" );

                    case .Reg;
                    if d
                    {
                        append( *out, RegToRegName( reg, w ) );
                        append( *out, ", " );
                        append( *out, RegToRegName( rm, w ) );
                        append( *out, "\n" );
                    }
                    else
                    {
                        append( *out, RegToRegName( rm, w ) );
                        append( *out, ", " );
                        append( *out, RegToRegName( reg, w ) );
                        append( *out, "\n" );
                    }
                }
            }
        }
    }

    write_entire_file( tprint( "%.dis.asm", filename ), builder_to_string( *out ) );
}
